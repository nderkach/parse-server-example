/**
 * Associate users with which experiments they are participating in, stored in UserStats.
 */

var exports;

(function () {
    'use strict';

    var _ = require('underscore');
    var moment = require('moment');
    var mixpanelImports = require('./mixpanelImports.js');

    var UserStats = Parse.Object.extend('UserStats');
    var MixpanelImports = Parse.Object.extend('MixpanelImports');

    var EXPERIMENTS_START_DATE = moment([2014, 10 - 1, 1]);

    Parse.Cloud.job("importMixpanelExperiments", function(request, status) {
        function usersCallback(users, rawEvents) {
            var newExperimentsByMixpanelId = {};
            rawEvents.forEach(function(rawEvent) {
                var obj = newExperimentsByMixpanelId[rawEvent.properties.$distinct_id] || {};
                obj[rawEvent.properties.$experiment_id] = rawEvent.properties.$variant_id;
                newExperimentsByMixpanelId[rawEvent.properties.$distinct_id] = obj;
            });

            // For now doesn't handle missing UserStats row, in general they should be there
            // and they can be generated by the job. It should be easy enough to just remove
            // all $experiment_started rows from the MixpanelImport table and then run this
            // again to repopulate experiment data from scratch.
            var statsIds = users.filter(function(u) {
                return u.has('stats');
            }).map(function(user) {
                return user.get('stats').id;
            });

            var query = new Parse.Query(UserStats);
            query.select('mixpanelExperiments');
            query.containedIn('objectId', statsIds);
            return query.find({useMasterKey:true}).then(function(allUserStats) {
                allUserStats.forEach(function(userStats) {
                    var experimentsObj = userStats.get('mixpanelExperiments') || {};
                    _.extend(experimentsObj, newExperimentsByMixpanelId[userStats.get('mixpanelId')]);
                    userStats.set('mixpanelExperiments', experimentsObj);
                });
                return Parse.Object.saveAll(allUserStats, {useMasterKey: true});
            });
        }
        mixpanelImports.importEventsFromMixpanel(['$experiment_started'], EXPERIMENTS_START_DATE, usersCallback).then(function(numRowsImported) {
            status.success("Done (" + numRowsImported + " rows imported)");
        }, function(error) {
            status.error("Error :( " + JSON.stringify(error));
        });
    });
})();
